#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <TinyGPSPlus.h>
#include <BluetoothSerial.h>
#include "FS.h"
#include "SPIFFS.h"

// Objects
Adafruit_MPU6050 mpu;
TinyGPSPlus gps;
BluetoothSerial SerialBT;

// GPS Pins
#define RXD2 16
#define TXD2 17

// Global variables
float prevAccelMag = 0.0;
float decel = 0.0;
unsigned long lastSave = 0;

void setup() {
  Serial.begin(115200);
  Serial2.begin(9600, SERIAL_8N1, RXD2, TXD2);
  SerialBT.begin("RiderTelemetry_Extended");
  Wire.begin();

  // Initialize MPU6050
  if (!mpu.begin()) {
    Serial.println("MPU6050 not found!");
    while (1);
  }

  // Initialize SPIFFS for local storage
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS Mount Failed");
    return;
  }

  // Configure MPU ranges
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  // Create or append log file
  File file = SPIFFS.open("/ride_log.csv", FILE_WRITE);
  if (file) {
    file.println("Timestamp,AccX,AccY,AccZ,Decel,Speed,Lat,Lon,RidingMode");
    file.close();
  }

  Serial.println("Rider Telemetry System Ready!");
  SerialBT.println("Rider Telemetry Connected");
}

void loop() {
  // --- Read MPU6050 ---
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // --- Read GPS ---
  while (Serial2.available() > 0)
    gps.encode(Serial2.read());

  float ax = a.acceleration.x;
  float ay = a.acceleration.y;
  float az = a.acceleration.z;

  // Compute acceleration magnitude
  float accelMag = sqrt(ax * ax + ay * ay + az * az);

  // Compute deceleration (drop in total acceleration)
  decel = prevAccelMag - accelMag;
  if (decel < 0) decel = 0;
  prevAccelMag = accelMag;

  // GPS Data
  double speedKmph = gps.speed.isValid() ? gps.speed.kmph() : 0.0;
  double lat = gps.location.isValid() ? gps.location.lat() : 0.0;
  double lon = gps.location.isValid() ? gps.location.lng() : 0.0;
  String timeStamp = gps.time.isValid()
                         ? String(gps.time.hour()) + ":" +
                               String(gps.time.minute()) + ":" +
                               String(gps.time.second())
                         : "NA";

  // --- Detect Riding Mode ---
  String ridingMode = detectMode(speedKmph, accelMag);

  // --- Format Data ---
  String dataString = "Time: " + timeStamp +
                      " | Acc: " + String(ax, 2) + "," + String(ay, 2) + "," + String(az, 2) +
                      " | Decel: " + String(decel, 2) +
                      " | Speed: " + String(speedKmph, 1) + " km/h" +
                      " | Mode: " + ridingMode +
                      " | Lat: " + String(lat, 6) +
                      " | Lon: " + String(lon, 6);

  // Print and send via Bluetooth
  Serial.println(dataString);
  SerialBT.println(dataString);

  // --- Save Data Every 1 Second ---
  if (millis() - lastSave > 1000) {
    File file = SPIFFS.open("/ride_log.csv", FILE_APPEND);
    if (file) {
      file.printf("%s,%.2f,%.2f,%.2f,%.2f,%.1f,%.6f,%.6f,%s\n",
                  timeStamp.c_str(), ax, ay, az, decel, speedKmph, lat, lon, ridingMode.c_str());
      file.close();
    }
    lastSave = millis();
  }

  delay(200);
}

// --- Function to Detect Riding Mode ---
String detectMode(double speed, float accelMag) {
  /*
    Classification logic:
    - Idle/Walking: speed < 3 km/h, low vibration (accelMag ~9.8 ± 1)
    - Scooter: speed between 3–25 km/h, moderate accel variation
    - Motorcycle: speed > 25 km/h, high accel or lean motion
  */

  if (speed < 3 && accelMag < 11.0 && accelMag > 8.0) {
    return "Idle/Walking";
  } else if (speed >= 3 && speed <= 25) {
    return "Scooter";
  } else if (speed > 25) {
    return "Motorcycle";
  } else {
    return "Unknown";
  }
}
